from collections import deque

def bfs_shortest_path(graph, start, n):
    """
    BFS to find shortest path from start to all other nodes
    Returns a dictionary with distances to all reachable nodes
    """
    distances = [-1] * (n + 1)  # -1 means unreachable
    distances[start] = 0
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        
        for neighbor in graph[current]:
            if distances[neighbor] == -1:  # Not visited
                distances[neighbor] = distances[current] + 1
                queue.append(neighbor)
    
    return distances

def check_admissibility(n, m, start, goal, heuristics, edges):
    """
    Check if heuristic values are admissible
    A heuristic is admissible if h(node) <= actual_shortest_distance(node, goal)
    """
    # Build adjacency list
    graph = [[] for _ in range(n + 1)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    # Find actual shortest distances from goal to all nodes using BFS
    actual_distances = bfs_shortest_path(graph, goal, n)
    
    # Check admissibility for each node
    inadmissible_nodes = []
    
    for node in range(1, n + 1):
        h_value = heuristics[node]
        actual_dist = actual_distances[node]
        
        # If node is reachable from goal
        if actual_dist != -1:
            # Heuristic should not overestimate the actual distance
            if h_value > actual_dist:
                inadmissible_nodes.append(node)
        # If node is unreachable from goal, heuristic should be infinity
        # But since we can't reach goal, any positive heuristic is inadmissible
        else:
            if h_value != float('inf'):  # In practice, check if h > 0 or defined
                inadmissible_nodes.append(node)
    
    return inadmissible_nodes

# Read input
n, m = map(int, input().split())
start, goal = map(int, input().split())

# Read heuristic values
heuristics = [0] * (n + 1)  # Index 0 unused, nodes are 1 to n
for _ in range(n):
    node, h_value = map(int, input().split())
    heuristics[node] = h_value

# Read edges
edges = []
for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))

# Check admissibility
inadmissible = check_admissibility(n, m, start, goal, heuristics, edges)

# Print output
if len(inadmissible) == 0:
    print(1)
else:
    print(0)
    print(f"Here nodes {', '.join(map(str, inadmissible))} are inadmissible.")from collections import deque

def bfs_shortest_path(graph, start, n):
    """
    BFS to find shortest path from start to all other nodes
    Returns a dictionary with distances to all reachable nodes
    """
    distances = [-1] * (n + 1)  # -1 means unreachable
    distances[start] = 0
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        
        for neighbor in graph[current]:
            if distances[neighbor] == -1:  # Not visited
                distances[neighbor] = distances[current] + 1
                queue.append(neighbor)
    
    return distances

def check_admissibility(n, m, start, goal, heuristics, edges):
    """
    Check if heuristic values are admissible
    A heuristic is admissible if h(node) <= actual_shortest_distance(node, goal)
    """
    # Build adjacency list
    graph = [[] for _ in range(n + 1)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    # Find actual shortest distances from goal to all nodes using BFS
    actual_distances = bfs_shortest_path(graph, goal, n)
    
    # Check admissibility for each node
    inadmissible_nodes = []
    
    for node in range(1, n + 1):
        h_value = heuristics[node]
        actual_dist = actual_distances[node]
        
        # If node is reachable from goal
        if actual_dist != -1:
            # Heuristic should not overestimate the actual distance
            if h_value > actual_dist:
                inadmissible_nodes.append(node)
        # If node is unreachable from goal, heuristic should be infinity
        # But since we can't reach goal, any positive heuristic is inadmissible
        else:
            if h_value != float('inf'):  # In practice, check if h > 0 or defined
                inadmissible_nodes.append(node)
    
    return inadmissible_nodes

# Read input
n, m = map(int, input().split())
start, goal = map(int, input().split())

# Read heuristic values
heuristics = [0] * (n + 1)  # Index 0 unused, nodes are 1 to n
for _ in range(n):
    node, h_value = map(int, input().split())
    heuristics[node] = h_value

# Read edges
edges = []
for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))

# Check admissibility
inadmissible = check_admissibility(n, m, start, goal, heuristics, edges)

# Print output
if len(inadmissible) == 0:
    print(1)
else:
    print(0)
    print(f"Here nodes {', '.join(map(str, inadmissible))} are inadmissible.")
